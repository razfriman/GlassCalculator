package com.cse3345.f13.friman;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Locale;
import java.util.Stack;

import android.text.TextUtils;
import android.util.Log;

/**
 * Class that can parse and compute the value of an arithmetic equation Builds a
 * tree that represents the equation in RPN (Reverse Polish Notation)
 * 
 * @author Raz Friman
 * 
 */
public class EquationParser {

	/**
	 * Preprocess the input text
	 * 
	 * @param input
	 * @return the preprocessed input, ready for tokenization
	 */
	public String preprocessEquation(String input) {
		String output = "";

		ArrayList<String> validTokens = new ArrayList<String>();

		input = input.toLowerCase(Locale.US);

		// Split the word by space
		for (String word : input.split("\\s+")) {
			if (word.length() > 0) {

				if (word.equals("one") || word.equals("won")) {
					validTokens.add("1");
				} else if (word.equals("two") || word.equals("to")
						|| word.equals("too")) {
					validTokens.add("2");
				} else if (word.equals("three")) {
					validTokens.add("3");
				} else if (word.equals("four") || word.equals("for")) {
					validTokens.add("4");
				} else if (word.equals("five")) {
					validTokens.add("5");
				} else if (word.equals("six")) {
					validTokens.add("6");
				} else if (word.equals("seven")) {
					validTokens.add("7");
				} else if (word.equals("eight") || word.equals("ate")) {
					validTokens.add("8");
				} else if (word.equals("nine")) {
					validTokens.add("9");
				} else if (word.equals("ten")) {
					validTokens.add("10");
				} else if (word.equals("plus")) {
					validTokens.add("+");
				} else if (word.equals("minus") || word.equals("negative")) {
					validTokens.add("-");
				} else if (word.equals("times")) {
					validTokens.add("*");
				} else if (word.equals("divided")) {
					validTokens.add("/");
				} else if (word.equals("what") || word.equals("is")
						|| word.equals("by")) {
					continue;
				} else {
					validTokens.add(word);
				}
			}
		}

		// Join the cleaned input by a single space to prepare for tokenization
		output = TextUtils.join(" ", validTokens);

		return output;
	}

	/**
	 * Tokenizes the preprocessed input into separate tokens
	 * 
	 * @param preprocessedInput
	 * @return List of tokens generated by the input text
	 */
	public ArrayList<String> tokenizeEquation(String preprocessedInput) {
		ArrayList<String> tokens = new ArrayList<String>();

		// Split the string by space
		String[] splitted = preprocessedInput.split("\\s");

		// Add each token to the array
		for (String token : splitted) {

			Log.d("RAZ","TOKEN: " + token);
			
			if (token.startsWith("-") && token.length() > 1
					&& isDouble(tokens.get(tokens.size() - 1))) {

				// Add the minus sign separately
				tokens.add("-");

				// Add the number token separately
				tokens.add(token.substring(1));
			} else {
				
				if (tokens.size() > 0) {
					// Try to fix non-combined tokens
					
					// 1 + 100 10 + 2
					// 1 + 110 + 2
					
					// 5
					
					String previous = tokens.get(tokens.size() - 1);
					
					Log.d("RAZ","old=" + previous);
					
					try {
						double prev = Double.parseDouble(previous);
						double current = Double.parseDouble(token.trim());
						
						tokens.remove(tokens.size() - 1);
						tokens.add(Double.toString(prev + current));
					} catch (NumberFormatException e) {
						
						// Not a number
						tokens.add(token.trim());
					}
					
				} else {
					tokens.add(token.trim());
				}
			}
		}

		return tokens;
	}

	private boolean isDouble(String input) {
		try {
			Double.parseDouble(input);
		} catch (NumberFormatException e) {
			// Not a number
			return false;
		}

		return true;
	}

	/**
	 * Build a parse tree for the equation using the Shunting-yard algorithm
	 * 
	 * @param tokens
	 * @return a LinkedList containing the Output Queue in RPN (Reverse Polish
	 *         Notation) form
	 */
	public LinkedList<Token> buildParseTree(ArrayList<String> tokens) {

		LinkedList<Token> outputQueue = new LinkedList<Token>();
		Stack<OperatorToken> operatorStack = new Stack<OperatorToken>();

		// Iterate through each token
		for (int i = 0; i < tokens.size(); i++) {
			String token = tokens.get(i);

			try {
				// Value
				double value = Double.parseDouble(token);

				// Add the value to the output queue
				outputQueue.add(new NumberToken(value));
			} catch (NumberFormatException e) {
				// Operator
				OperatorToken operator = new OperatorToken(token);

				// Pop and push all operators on the stack with higher
				// precedence than the current operator
				while (!operatorStack.isEmpty()
						&& operator.mPrecedence <= operatorStack.peek().mPrecedence) {
					outputQueue.add(operatorStack.pop());
				}

				// Add the operator to the operator stack
				operatorStack.push(operator);
			}
		}

		// Pop the remaining operators from the stack and push them on to the
		// queue.
		while (!operatorStack.isEmpty()) {
			outputQueue.add(operatorStack.pop());
		}

		return outputQueue;
	}

	/**
	 * Computes the result of a parsed RPN expression
	 * 
	 * @param rpnTree
	 * @return The result of the arithmetic expression
	 */
	public double computeResult(LinkedList<Token> rpnTree) {

		double result = 0;

		// 18 45 10
		// 18 450
		// -420
		//18 45 10 * -
		// 18 450 -
		// -432
		// Queue to hold all temporary computations
		LinkedList<NumberToken> modifiedRpn = new LinkedList<NumberToken>();

		// Iterate through the tree
		for (int i = 0; i < rpnTree.size(); i++) {
			Token t = rpnTree.get(i);

			if (t instanceof NumberToken) {
				// Add numbers to the temporary queue
				modifiedRpn.add((NumberToken) t);
			} else if (t instanceof OperatorToken) {
				if (modifiedRpn.size() >= 2) {

					// Dequeue two operands for each operator
					NumberToken t2 = (NumberToken) modifiedRpn.removeLast();
					NumberToken t1 = (NumberToken) modifiedRpn.removeLast();

					Log.d("RAZ","A=" + t1.mDoubleValue + "   b=" + t2.mDoubleValue);
					// Compute the result of the operation
					double operationResult = ((OperatorToken) t).computeOperator(t1.mDoubleValue, t2.mDoubleValue);

					Log.d("RAZ","OP RESULT " + operationResult);
					
					// Push the value into the queue
					modifiedRpn.add(new NumberToken(operationResult));
				}
			}
		}

		// The result will value of the first token in the modified queue
		result = modifiedRpn.get(0).mDoubleValue;
		
		Log.d("RAZ","RESULT SIZE: " + modifiedRpn.size());
		Log.d("RAZ","RESULT:" + result);

		return result;
	}

	/**
	 * Handle the complete process of computing the value of an equation in
	 * string format.
	 * 
	 * @param input
	 * @return the value of the arithmetic expression
	 */
	public double parseEquation(String input) {

		double result = 0;

		// Preprocess the user input
		String preprocessed = preprocessEquation(input);

		// Tokenize the preprocessed text
		ArrayList<String> tokens = tokenizeEquation(preprocessed);

		// Generate a parse tree from the input
		LinkedList<Token> rpnTree = buildParseTree(tokens);

		// Compute the result of the expression using the parse tree
		result = computeResult(rpnTree);

		return result;
	}
}
